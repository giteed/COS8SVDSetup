
#!/bin/bash
# --> Прочитать настройки из /root/.bashrc
. /root/.bashrc


# функция shredder выводит отладочное сообщение в виде списка файлов соответствующих маске
function shredder() {
    
    echo " function shredder: OK"
    echo " Отладка (найдено по маске): "$@" "
    
  }

# touch *_files.log
touch {1..3}_files.log

# функция sootv_maske проверяет соответствие файла маске, и если он соотвествует, то передает его в функцию shredder
# скрипту можно передать так же и путь по которому будет идти проверка пример : $path/_files.log выдаст 3 файла *_files.log
# созданные заранее в текущем каталоге этим скриптом. Если текущий каталог /root/temp то команда может выглядеть так:
# ./obrabotka_po_maske.sh /root/temp/*_files.log

 function sootv_maske() {
   shopt -s nullglob
   
   #files=(*_files.log)
   files=($@)
    
    if [ "${#files[@]}" -gt 0 ]; then
      shredder "${files[@]}"
    else
      echo " Нет файлов, соответствующих маске"
    fi
    
    shopt -u nullglob  # Выключение опции nullglob
    
  }


path="$(pwd)"
sootv_maske $@

 exit 0





echo " Готово!"





function msg() {
      ttb=$(echo -e " 
       Чтобы посмотреть как работает этот пример, скрипт создаст 
       в текущей директории запуска три файла *_files.log
       а именно 1_files.log 2_files.log 3_files.log
       
       для тестирования нужно передать скрипту: 
       
       # $0 *_files.log (что соответствует маске указанной в скрипте) 
       или: 
       
       # $path/$0 *_files.log (что соответствует маске указанной в скрипте) 
        или: 
       
       # $0 *_files.blog (что НЕсоответствует маске указанной в скрипте) 
       Затем сравнить выводы от скрипта.
       
       В этом скрипте, благодаря опции nullglob, мы можем обрабатывать 
       пустые шаблоны файлов без ошибок и выполнять соответствующие действия, 
       если файлы соответствующего шаблона существуют.
      
        Более подробно смотри в скрипте после exit 0 
        | files=(*_files.log)
        | (ВНИМАНИЕ: В скрипте этот массив закомментирован, 
        | и вместо него стоит массив files=($@) который принимает на вход 
        | любые маски, чтобы протестировать по описанию нужно 
        | закоментировать files=($@) и раскоментировать files=(*_files.log) 
        | Но в обоих случаях предоставлен полезный пример работы данных функций,
        | которые могут применяться при отборе нужных файлов по маске)
      
      ") && lang=cr && bpn_p_lang ; echo ;
  }

  
 


Определение функции shredder, которая будет выполнять перемещение файлов:

function shredder() {
    echo shredder_OK
    echo "отладка: $@"
}

Включение опции nullglob с помощью команды shopt -s nullglob. Опция nullglob позволяет обрабатывать пустые шаблоны файлов, если соответствующих файлов не найдено. Это означает, что если маска файлов не соответствует ни одному файлу, она будет раскрыта в пустой список файлов.

shopt -s nullglob

Определение массива files с помощью маски *_files.log. Здесь используется раскрытие маски файлов, и все файлы, соответствующие данной маске, будут помещены в массив files.

files=(*_files.log)
(ВНИМАНИЕ: В скрипте этот массив закомментирован, и вместо него стоит массив files=($@) который принимает на вход любые маски, чтобы протестировать по описанию нужно закоментировать files=($@) и раскоментировать files=(*_files.log) Но в обоих случаях предоставлен полезный пример работы данных функций, которые могут применяться при отборе нужных файлов по маске)

Проверка, что массив files содержит хотя бы один элемент, с помощью условного оператора if. Если массив не пустой, вызывается функция shredder с передачей всех элементов массива в качестве аргументов.

if [ "${#files[@]}" -gt 0 ]; then
    shredder "${files[@]}"
else
    echo "Нет файлов, соответствующих маске"
fi

Выключение опции nullglob с помощью команды shopt -u nullglob. Это восстанавливает стандартное поведение обработки пустых шаблонов файлов.

shopt -u nullglob

Конец скрипта.

exit 0

В этом скрипте, благодаря опции nullglob, мы можем обрабатывать пустые шаблоны файлов без ошибок и выполнять соответствующие действия, если файлы соответствующего шаблона существуют.


dotglob это что?
ChatGPT

dotglob - это опция оболочки Bash, которая влияет на раскрытие маски файлов. Когда dotglob включен, маска файлов будет включать также и скрытые файлы, начинающиеся с точки.

По умолчанию, когда dotglob выключен, скрытые файлы не включаются в раскрытие маски файлов. Например, если у вас есть файлы file1, file2 и .hidden_file, и вы используете маску *, то только file1 и file2 будут раскрыты.

Однако, если вы включите dotglob с помощью shopt -s dotglob, то при использовании маски * будут раскрыты все файлы, включая скрытые файлы, такие как .hidden_file.

Пример использования dotglob:


shopt -s dotglob  # Включение опции dotglob
files=(*)
echo "${files[@]}"  # Вывод всех файлов, включая скрытые
shopt -u dotglob  # Выключение опции dotglob

Обратите внимание, что при использовании dotglob следует быть осторожным, так как это может привести к раскрытию большого количества файлов, включая скрытые файлы, что может быть неожиданным.


https://linuxcookbook.ru/books/absguide/ch18s02.html



18.2. Globbing -- Подстановка имен файлов

Bash, сам по себе, не распознает регулярные выражения. Но в сценариях можно использовать команды и утилиты, такие как sed и awk, которые прекрасно справляются с обработкой регулярных выражений.

Фактически, Bash может выполнять подстановку имен файлов, этот процесс называется "globbing", но при этом не используется стандартный набор регулярных выражений. Вместо этого, при выполнении подстановки имен файлов, производится распознавание и интерпретация шаблонных символов. В число интерпретируемых шаблонов входят символы * и ?, списки символов в квадратных скобках и некоторые специальные символы (например ^, используемый для выполнения операции отрицания). Применение шаблонных символов имеет ряд важных ограничений. Например, если имена файлов начинаются с точки (например так: .bashrc), то они не будут соответствовать шаблону, содержащему символ *. [49] Аналогично, символ ? в операции подстановки имен файлов имеет иной смысл, нежели в регулярных выражениях.

bash$ ls -l
total 2
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 a.1
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 b.1
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 c.1
 -rw-rw-r-- 1 bozo bozo 466 Aug 6 17:48 t2.sh
 -rw-rw-r-- 1 bozo bozo 758 Jul 30 09:02 test1.txt

bash$ ls -l t?.sh
-rw-rw-r-- 1 bozo bozo 466 Aug 6 17:48 t2.sh

bash$ ls -l [ab]*
-rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 a.1
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 b.1

bash$ ls -l [a-c]*
-rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 a.1
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 b.1
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 c.1

bash$ ls -l [^ab]*
-rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 c.1
 -rw-rw-r-- 1 bozo bozo 466 Aug 6 17:48 t2.sh
 -rw-rw-r-- 1 bozo bozo 758 Jul 30 09:02 test1.txt

bash$ ls -l {b*,c*,*est*}
-rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 b.1
 -rw-rw-r-- 1 bozo bozo 0 Aug 6 18:42 c.1
 -rw-rw-r-- 1 bozo bozo 758 Jul 30 09:02 test1.txt

Bash выполняет подстановку имен файлов при использовании аргументов командной строки без кавычек. Команда echo наглядно демонстрирует это.

bash$ echo *
a.1 b.1 c.1 t2.sh test1.txt

bash$ echo t*
t2.sh test1.txt

Note 	

Bash предоставляет возможность изменить порядок интерпретации специальных символов во время подстановки имен файлов. Так команда set -f запрещает подстановку, а ключи nocaseglob и nullglob в shopt изменяют характер подстановки.

См. также Пример 10-4.
Notes
[49] 	

Подстановка таких имен файлов возможна, но только при условии, что символ точки будет явно присутствовать в шаблоне.


~/[.]bashrc # Не будет соответствовать имени ~/.bashrc
~/?bashrc # То же самое.
 # Метасимволы не могут соответствовать символу точки при подстановке имен файлов.

~/.[b]ashrc # Имя ~./bashrc будет соответствовать данному шаблону
~/.ba?hrc # Аналогично.
~/.bashr* # Аналогично.

# Установка ключа "dotglob" отключает такое поведение интерпретатора.
# Спасибо S.C.
