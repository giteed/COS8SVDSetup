

#!/bin/bash

# Source global definitions
# --> Прочитать настройки из /root/.bashrc
source /root/.bashrc

# --> Прочитать настройки:
. /root/bin/utility/.varfunc.sh &>/dev/null ;
. /root/bin/utility/.css.sh &>/dev/null ;


debug_message ;


#lang_x ;
lang=$1 ;
if [[ $1 == "" ]] ; then lang=cr ; fi ;


ttb=$(echo -e "
 ⎧ sudo: 
 ⎩ Добавление пользователя в группу sudo (wheel)
 
 ⎧ Если нужно, добавляем нового пользователя "username":
 ⎩ # adduser username
 
 ⎧ Назначаем пароль пользователю "username":
 ⎩ # passwd username
 
 ⎧ Если получаем ошибку \"usermod: group 'sudo' does not exist\" 
 | при попытке добавить пользователя в группу sudo (wheel)
 | - вводим команду чтобы отредактировать файл /etc/sudoers :
 ⎩ # visudo
 
 ⎧ Затем в файле нужно раскоментировать строку:
 |
 ⎩ %wheel  ALL=(ALL)       ALL
 
 ⎧ Если хотим переключаться на другого пользователя командой 
 | # su username 
 | или выполнять команды от имени других пользователей входящих 
 | в группу sudo (wheel) без необходимости ввода пароля 
 | - снимаем коммент со строки:
 |
 ⎩ %wheel        ALL=(ALL)       NOPASSWD: ALL
 " ) && (lang_nix && bpn_p_lang ; ttb="" ; lang="") ;
 
 ttb=$(echo -e "
 ⎧ ВНИМАНИЕ: Никогда не редактируйте файл /etc/sudoers в обычном 
 | текстовом редакторе! Всегда используйте для этой цели 
 | только команду visudo!
 |
 | # visudo 
 | # man visudo
 ⎩ # tldr visudo
 " ) && bpn_p_lang ; ttb="" ;
 tldr visudo

ttb=$(echo -e "
 ⎧ Чтобы добавить пользователя в группу, выполните 
 | приведенную ниже команду от имени пользователя root 
 | или другого пользователя sudo. Измените «username» 
 | на имя пользователя, которому вы хотите 
 | предоставить разрешения.
 |
 ⎩ # usermod -aG wheel username

 ⎧ Предоставления доступа sudo с использованием этого метода 
 | достаточно для большинства случаев использования.
 | Чтобы проверить доступ к sudo, запустите команду whoami:
 |
 ⎩ # sudo whoami

 ⎧ Вам будет предложено ввести пароль. Если у пользователя есть 
 | доступ к sudo, команда выведет «root». Если вы получаете 
 | сообщение «user is not in the sudoers file» (пользователь 
 | отсутствует в файле sudoers), это означает, 
 ⎩ что у пользователя нет привилегий sudo.
 
 ⎧ ВЫВОД:
 | Предоставление пользователю доступа sudo - простая задача, все, 
 | что вам нужно сделать, это добавить пользователя 
 | в группу «wheel».
 | 
 | Подробнее о добавлении пользователей в группу sudo (wheel)
 ⎩ https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-ru


" ) && bpn_p_lang ; ttb="" ;



exit 0 ;







Добавление пользователя в группу sudo (wheel)


Добавляем нового пользователя "username"
# adduser username

Назначаем пароль пользователю "username"
# passwd username


Если получаем ошибку "usermod: group 'sudo' does not exist" при попытке добавить пользователя в группу sudo (wheel) - вводим команду чтобы отредактировать файл /etc/sudoers :
# visudo

Затем в файле нужно раскоментировать строку:
%wheel  ALL=(ALL)       ALL

Если хотим переключаться на другого пользователя командой su username или выполнять команды от имени других пользователей входящих в группу sudo (wheel) без необходимости ввода пароля - снимаем коммент со строки:
%wheel        ALL=(ALL)       NOPASSWD: ALL


Для добавления пользователя "username" в группу sudo (wheel) вводим команду:
# usermod -aG wheel username (для CentOS)
# sudo usermod -aG sudo user (для других)



ВНИМАНИЕ: Никогда не редактируйте файл /etc/sudoers в обычном текстовом редакторе! Всегда используйте для этой цели только команду visudo!


Подробнее о добавлении пользователей в группу sudo (wheel)
https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-ru




Основные понятия работы в редакторе vi

В любой момент при работе в редакторе vi вы находитесь в одном из трёх режимов редактора: командный режим (command mode), режим ввода (insert mode) и режим последней строки (last line mode).

══ При запуске редактора vi вы оказываетесь в командном режиме. В этом режиме можно давать команды для редактирования файлов или перейти в другой режим. Например, вводя x в командном режиме мы удаляем символ, на который указывает курсор. Клавиши-стрелки перемещают курсор по редактируемому файлу. Как правило, команды, используемые в командном режиме, состоят из одного или двух символов.

════ Основной ввод и редактирование текста осуществляется в режиме ввода. При использовании редактора vi основное время, скорее всего, будет проводиться именно в этом режиме. Переход в режим ввода из командного режима осуществляется командой i (от слова insert). Находясь в режиме ввода, можно вводить текст в то место, куда указывает курсор. Выход из режима ввода в командный режим осуществляется клавишей Esc.

══ Режим последней строки — это специальный режим, в котором редактору даются сложные команды. При вводе этих команд они отображаются в последней строке экрана (отсюда пошло название режима). Например, если ввести в командном режиме команду :, то осуществится переход в режим последней строки, и можно будет вводить такие команды, как wq (записать файл и покинуть редактор vi) или q! (выйти из редактора vi без сохранения изменений). В режиме последней строки обычно вводятся команды, название которых состоит из нескольких символов. В этом режиме в последнюю строку вводится команда, после чего нажимается клавиша Enter, и команда исполняется.


Подробно о работе с редактором vi
https://docs.altlinux.org/ru-RU/archive/2.3/html-single/junior/alt-docs-extras-linuxnovice/ch02s10.html











exit 0 ;




















new_V=$(cat /tmp/.ver.txt)
current_V=$(cat /root/.ver.txt)

if [ ${new_V} != ${current_V} ] 
then /root/bin/utility/gh-ss.sh ;
else /root/bin/utility/gh-ss.sh ; exit 0 ;
fi 

 ⎧ 
 | 
 ⎩ 
 
 
 
exit 0 ; 

(ttb=$(echo -e "  " ) && bpn_p_lang ; ttb="" ) ;
(ttb=$(echo -e "  " ) && bpn_p_lang ; ttb="" ) ;


&& green_tick_en && ttb=$

&& lang="nix" && bpn_p_lang


echo -e "${TOR_or_REAL_IP_MSG}" ;

echo -e "\n $(black_U23A7 ) " ;
echo -e " $(white_1     ) "
echo -e " $(red_1       ) "
echo -e " $(blue_1      ) "
echo -e " $(cyan_1      ) "
echo -e " $(purple_1    ) "
echo -e " $(purple_U23A6) "
echo -e " $(black_1     ) "
echo -e " $(white_1     ) "
echo -e " $(ellow_1     ) " ;
echo -e " $(green_1     ) "
echo -e " $(green_U23A6 ) "
echo -e " $(white_1     ) $(red_U0023) " ;
echo -e " $(white_1     )  " ;
echo -e " $(black_U23A9 ) \n" ;
echo ;














# Make SWAP:
[[ -f /tmp/installer/make_swap.sh ]] && echo all ok || echo install ;
[[ -f /etc/yum.repos.d/epel.repo ]] && echo all ok || echo installing epel.repo pls;


# Nano (syntax):
function NanoSyntaxOK() # /root/.nanorc найден (cat нашел и открыл /root/.nanorc)
	{
		echo OK ;
	}
function NanoSyntaxIN() # /root/.nanorc НЕ найден или пуст (cat получает пустое значение потому что /root/.nanorc нет или он пуст)
	{
		echo install ;
	}

[[ -z $( cat /root/.nanorc ) ]] 2>/dev/null && NanoSyntaxIN || NanoSyntaxOK ;




Пример 5
Если файл bashrc существует, то печатает в консоль «Файл существует!», иначе печатает «Файл не существует!»
#!/bin/bash 
if [ -f "$HOME/.bashrc" ]; then 
	echo "Файл существует!" 
else 
	echo "Файл не существует!" 
fi


Ключи к файлам и каталогам
[ -ключ “путь” ] [ -e “путь каталогу_или_файлу”] – существует ли файл или каталог.
[ -r “путь к файлу/каталогу”] – доступен ли файл/каталог для чтения.
[ -f “путь к файлу/каталогу”] – существует ли файл.
[ -d “путь к каталогу”] – существует ли каталог. Полное описание возможных применений различных скобок, правильное расставление кавычек уходит далеко от темы, поэтому могу посоветовать обратится к руководству Advanced Bash Scripting
Арифметика




echo -e " $(black_U23A7    ) " ;
echo -e " $(ellow_1        ) $(green_arrow) XXXXXXXXXX " ;
echo -e " $(white_1        ) " ;
echo -e " $(red_1          ) " ;
echo -e " $(purple_U23A6   ) " ;
echo -e " $(blue_1         ) " ;
echo -e " $(black_1        ) " ;
echo -e " $(black_U23A9    )\n" ;




   function press_enter()
 {
	echo -en "   <<< "$RED"# ${ELLOW}PRESS ENTER ${NC}to continue...\n\n       (or esc + enter to cancel) "
	read yesno
	
	if [[ "$yesno" == "" ]]
	then css ;
	   echo -e ;
	else 
	   exit 0 ;
		  
	fi ;
 }



 " | bat --paging=never -l nix -p ;











# Циклы



test_connect() {
	

	URL_CHECK="http://$(ifconfig_real_ip):8081"

	for i in {0..20}; do
	 
		 echo -en " $i " ; 
		 content=$(curl -s "${URL_CHECK}" | head -n 1 )
		 
		 
		 
		 if [[ "$content" == "" ]] ; 
		 then echo -e "${RED} Сервер $URL_CHECK выключен :(" ; 
		 sleep 2
		 
		 fi ;
		 
		 
		 
		 if [[ "$content" != "" ]] ; 
		 then echo -e "${GREEN} Сервер $URL_CHECK включен!" ; 
		 sleep 2
		 echo OK && exit 0 ;
		 
		 
		 fi ;
		 
	 
	 done
	 
	 echo "error"
	 
}

test_connect


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

		content=$(curl -s "${URL_CHECK}" | head -n 1 ) && echo $i
		
		# На входе в цикл проверяется, больше ли нуля переменная $var1. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только $var1 примет значение 0, цикл прекращается.
		var1=5
		while [ $var1 -gt 0 ]
		do
		echo $var1
		var1=$[ $var1 - 1 ]
		done

		
		if [ $i -eq 0 ]; then
			echo -en "\n $(black_U23A7 )" ; ttb=$(echo -e " Чото") && bpn_p_lang ;
			echo -en " $(black_U23A9 )" ; ttb=$(echo -e " # curl -s ${URL_CHECK} ") && bpn_p_lang ; echo ;
			
			ttb=$(echo -e "${content}\n") && bpn_p_lang ; echo ;
			return
		fi

		sleep 2
	done

	echo "error"

}






function check() {
check_tor_connect2
check_tor_connect

}




test_connect












exit 0;





test_connect() {
	

	URL_CHECK="http://$(ifconfig_real_ip):8081"

	for i in {0..20}; do
	 
		 echo -en " $i " ; 
		 content=$(curl -s "${URL_CHECK}" | head -n 1 )
		 
		 
		 
		 if [[ "$content" == "" ]] ; 
		 then echo -e "${RED} Сервер $URL_CHECK выключен :(" ; 
		 sleep 2
		 
		 fi ;
		 
		 
		 
		 if [[ "$content" != "" ]] ; 
		 then echo -e "${GREEN} Сервер $URL_CHECK включен!" ; 
		 sleep 2
		 echo OK && exit 0 ;
		 
		 
		 fi ;
		 
	 
	 done
	 
	 echo "error"
	 
}

test_connect






echo Вот — то же самое, но уже для цикла while:

#!/bin/bash
var1=1
while [ $var1 -lt 10 ]
echo "Number z: $var1"
var1=$(( $var1 - 2 ))
echo "Number zx: $var1"
sleep 1 ;
do
if [ $var1 -eq -5 ]
then  var1=10 ;
#break
fi
echo "Iteration: $var1"
var1=$(( $var1 + 1 ))
done

echo Команда break, исполненная, когда значение \$var1 станет равно 5, прерывает цикл. В консоль выведется то же самое, что и в предыдущем примере.







exit 0




# На входе в цикл проверяется, больше ли нуля переменная $var1. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только $var1 примет значение 0, цикл прекращается.
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done



# Ниже показано то, что выведет этот скрипт. Как видно, сначала выполняется первая итерация внешнего цикла, потом — три итерации внутреннего, после его завершения снова в дело вступает внешний цикл, потом опять — внутренний.

for (( a = 1; a <= 3; a++ ))
do
echo "Start a $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop b: $b"
done
done


# Один из самых распространённых вариантов использования циклов for в bash-скриптах заключается в обходе файлов, находящихся в некоей директории, и в обработке этих файлов.

Например, вот как можно вывести список файлов и папок:
for file in /root/*
do
if [ -d "$file" ]
then
ttb=$(echo "$file is a directory" ) && bpn_p_lang
elif [ -f "$file" ]
then
ttb=$(echo "$file is a file"  ) && bpn_p_lang
fi
done

echo Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла /etc/passwd:

#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done






exit 0 ;


# https://habr.com/ru/company/ruvds/blog/325928/


# читает и построчно выводит файл на экран (если нет пробелов)
# если пробелы есть то будет выводить все что ими разделено + построчно

# Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется IFS (Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:

# Пробел
# Знак табуляции
# Знак перевода строки

# IFS=$'\n'

# После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.

cd /etc/
file="/etc/passwd"
IFS=$'\n'
#IFS=$'\n. :'
for var in $(cat $file) 
do
lang=passwd
ttb=$(echo " $var" ) && bpn_p_lang
sleep 1;
done

exit 0 ;



for count in ; do
if [ $count -lt 1 2 3 4 5 6 7 8 ]; then
	echo $count
	count=$(( $count + 1 ))

fi
done ;


echo Команда break
echo Эта команда позволяет прервать выполнение цикла. Её можно использовать и для циклов for, и для циклов while:
echo прервет на 4
echo Такой цикл, в обычных условиях, пройдётся по всему списку значений из списка. Однако, в нашем случае, его выполнение будет прервано, когда переменная \$var1 будет равна 5.


for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done



echo Вот — то же самое, но уже для цикла while:

#!/bin/bash
var1=1
while [ $var1 -lt 10 ]
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Iteration: $var1"
var1=$(( $var1 + 1 ))
done

echo Команда break, исполненная, когда значение \$var1 станет равно 5, прерывает цикл. В консоль выведется то же самое, что и в предыдущем примере.



for var in first second third fourth fifth
do
echo The $var item
done

for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done





# Цикл while
# Здесь сначала мы устанавливаем значение счетчика в единицу, затем, в условии сравниваем его с 5, пока счетчик меньше пяти будут выполняться команды из блока do-done. Но еще в этом блоке нам нужно увеличивать значение счетчика на единицу, что мы и делаем.
x=1
while [ $x -lt 5 ]
do
echo "Значение счетчика: $x"
x=$(( $x + 1 ))
done



#Обратите внимание, как выполняется проверка условия. Значение счетчика сравнивается с эталоном. Действие с переменной счетчиком выполняется сразу же после завершения основного блока команд, а уже потом делается сравнение. Таким образом, у нас при первом выполнении i равно 1, а после него уже два 2. Теперь к завершению девятого прохода значение счетчика будет увеличено на единицу и станет 10. Условие сравнения 10 < 10 не верно, поэтому цикл дальше не выполняется.
for (( i=1; i<10; i++ ))
do
echo Значение счетчика $i
#check
if [[ i -gt 5 ]] ; then break ; fi 
done


#Этот код выведет список чисел от 1 до 10.
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done

# Цикл until
#Нам осталось рассмотреть последний цикл. Это цикл until. Он очень похож на while и отличается от него только работой условия. Если в первом нужно чтобы условие всегда было истинным, то здесь все наоборот. Цикл будет выполняться пока условие неверно. 

# Мы задаем значение счетчика 1 и увеличиваем его на единицу при каждом проходе. Как только условие счетчик больше 10 выполнится, сразу цикл будет остановлен. В циклах while и until тоже можно использовать команды break и continue для выхода из цикла и завершения текущего прохода, но мы не будем это очень подробно рассматривать.

count=1
until [ $count -gt 10 ]
do
echo "Значение счетчика: $count"
count=$(( $count + 1 ))
done



# Цикл while 
# Программа будет запрашивать новые строки пока вы не передадите ей символ конца файла с помощью сочетания клавиш Ctrl+D. Бесконечный цикл while bash с помощью while еще проще организовать:
while read line
do
echo $line
done


# В циклах while и until тоже можно использовать команды break и continue для выхода из цикла и завершения текущего прохода, но мы не будем это очень подробно рассматривать.


echo -e "
Команда continue

Когда в теле цикла встречается эта команда, текущая итерация завершается досрочно и начинается следующая, при этом выхода из цикла не происходит. Посмотрим на команду continue в цикле for:
"


for (( var1 = 1; var1 < 15; var1++ ))
do

if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
echo gogo пропускаем $var1
continue
fi

echo "Iteration number: $var1"
done

===================
echo "
ЦИКЛ ПО ДИАПАЗОНУ НОМЕРОВ 
Вы можете использовать выражение последовательности, чтобы указать диапазон чисел или символов, задав начальную и конечную точку диапазона. Выражение последовательности принимает следующую форму:

{START..END}
 

Вот пример цикла, который перебирает все числа от 0 до 3:

for i in {0..3}
do
  echo "Number: $i"
done
 

Number: 0
Number: 1
Number: 2
Number: 3
 
Начиная с Bash 4, также можно указать приращение при использовании диапазонов. Выражение принимает следующую форму:

{START..END..INCREMENT}
 

Вот пример, показывающий, как увеличить на 5:

for i in {0..20..5}
do
  echo "Number: $i"
done
 

Number: 0
Number: 5
Number: 10
Number: 15
Number: 20
==================="











exit 0 ;
